// backend/server.ts
import express, { Request, Response, NextFunction } from 'express';
import cors from 'cors';
import axios, { AxiosResponse } from 'axios';
import * as cheerio from 'cheerio';
import { GoogleGenerativeAI } from '@google/generative-ai';
import dotenv from 'dotenv';

dotenv.config();

// Types definitions
interface WebContent {
  url: string;
  content: string;
  title: string;
  success: boolean;
  length: number;
  note?: string;
  error?: string;
}

interface SearchResult {
  title: string;
  snippet: string;
  link: string;
  displayLink: string;
  formattedUrl?: string;
}

interface AnalysisResult {
  isFakeNews: boolean;
  confidence: number;
  reason: string;
  indicators: string[];
  recommendation: string;
  webEvidenceUsed: boolean;
  sourcesAnalyzed: number;
  twoStepProcess?: boolean;
  originalUrl?: string;
  searchQueries?: string[];
  identifiedTitle?: string;
  keyTopics?: string[];
  limitedAnalysis?: boolean;
  reason_limited?: string;
  error?: string;
  twoStepFindings?: string;
  firstStepAnalysis?: string;
  secondStepAnalysis?: string;
  consistencyCheck?: string;
  mainTopicVerification?: string;
  sourceDistribution?: string;
  domainAnalysis?: string;
  topicAnalysis?: string;
}

interface FirstStepAnalysisResult {
  mainTitle: string;
  keyTopics: string[];
  coreContent: string;
  mainEntities: string[];
  eventLocation: string;
  eventType: string;
  urgencyLevel: string;
}

interface WebAnalysisResult {
  detailedAnalysis: string;
  supportingEvidence: string[];
  contradictingEvidence: string[];
  sourceAnalysis: { [key: string]: string };
  contextualFactors: string[];
  nuancesFound: string[];
  crossReferenceFindings: string;
  contentBasedConclusion: string;
}

interface HistoryEntry {
  id: number;
  text: string;
  result: AnalysisResult;
  sourcesAnalyzed: number;
  analysisType: string;
  timestamp: string;
  originalUrl?: string;
  identifiedTitle?: string;
  keyTopics?: string[];
  twoStepProcess?: boolean;
}

interface Statistics {
  analysisMode?: string;
  originalUrl?: string;
  sourcesAnalyzed?: number;
  identifiedTitle?: string;
  keyTopics?: string[];
  searchQueries?: string[];
  twoStepEnabled?: boolean;
  note?: string;
  totalSitesFound?: number;
  sitesAnalyzed?: number;
  totalContentLength?: number;
  sourceDomains?: string[];
}

interface ApiResponse {
  success: boolean;
  analysis?: AnalysisResult;
  originalText?: string;
  twoStepProcess?: boolean;
  originalUrl?: string;
  statistics?: Statistics;
  webContents?: Array<{
    url: string;
    title: string;
    length: number;
    preview: string;
  }>;
  error?: string;
  details?: string;
  url?: string;
  isUrl?: boolean;
}


const ngayHienTai = new Date();
const thang = ngayHienTai.getMonth() + 1;
const nam = ngayHienTai.getFullYear();

const app = express();
const port = process.env.PORT || 5000;

// Kh·ªüi t·∫°o Gemini AI - s·ª≠ d·ª•ng gemini-2.0-flash thay v√¨ gemini-1.5-flash
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY as string);
const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });

app.use(cors());
app.use(express.json());

// L·ªãch s·ª≠ ph√¢n t√≠ch (l∆∞u trong memory)
let analysisHistory: HistoryEntry[] = [];

// C·∫•u h√¨nh User-Agent ƒë·ªÉ tr√°nh b·ªã block
const USER_AGENTS: string[] = [
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
  'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
];

// H√†m l·∫•y User-Agent ng·∫´u nhi√™n
function getRandomUserAgent(): string {
  return USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)];
}

// H√†m tr√≠ch xu·∫•t n·ªôi dung text t·ª´ HTML
function extractTextFromHTML(html: string): string {
  try {
    const $ = cheerio.load(html);
    
    // Lo·∫°i b·ªè c√°c th·∫ª kh√¥ng c·∫ßn thi·∫øt
    $('script, style, nav, footer, header, aside, .advertisement, .ads, .social-share, .comments, .sidebar').remove();
    
    // L·∫•y n·ªôi dung ch√≠nh
    let mainContent = '';
    
    // ∆Øu ti√™n c√°c selector ph·ªï bi·∫øn cho n·ªôi dung ch√≠nh
    const contentSelectors: string[] = [
      'article',
      '[role="main"]', 
      '.content',
      '.article-content',
      '.post-content',
      '.entry-content',
      '.article-body',
      '.story-body',
      '.content-body',
      'main',
      '.main-content',
      '.post-body',
      '.article-text',
      '.story-content',
      '#content',
      '.news-content'
    ];
    
    for (const selector of contentSelectors) {
      const element = $(selector);
      if (element.length > 0) {
        const elementText = element.text().trim();
        if (elementText.length > 100) {
          mainContent = elementText;
          break;
        }
      }
    }
    
    // N·∫øu kh√¥ng t√¨m th·∫•y n·ªôi dung ch√≠nh, l·∫•y to√†n b·ªô body
    if (!mainContent || mainContent.length < 100) {
      const bodyText = $('body').text().trim();
      if (bodyText.length > 0) {
        mainContent = bodyText;
      }
    }
    
    // N·∫øu v·∫´n kh√¥ng c√≥, l·∫•y to√†n b·ªô text
    if (!mainContent || mainContent.length < 50) {
      mainContent = $.text().trim();
    }
    
    // L√†m s·∫°ch text
    if (mainContent) {
      mainContent = mainContent
        .replace(/\s+/g, ' ')
        .replace(/\n+/g, '\n')
        .replace(/\t+/g, ' ')
        .trim();
    }
    
    return mainContent || '';
    
  } catch (error) {
    console.error("L·ªói khi tr√≠ch xu·∫•t text t·ª´ HTML:", (error as Error).message);
    return '';
  }
}

// H√†m tr√≠ch xu·∫•t title t·ª´ HTML
function extractTitleFromHTML(html: string): string {
  try {
    const $ = cheerio.load(html);
    return $('title').text().trim() || $('h1').first().text().trim() || '';
  } catch (error) {
    return '';
  }
}


// H√†m fetch n·ªôi dung t·ª´ URL v·ªõi retry logic v√† error handling c·∫£i ti·∫øn
async function fetchWebContent(url: string, maxRetries: number = 1): Promise<WebContent> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`üåê ƒêang fetch n·ªôi dung t·ª´: ${url} (l·∫ßn th·ª≠ ${attempt})`);
      
      const response: AxiosResponse<string> = await axios.get(url, {
        headers: {
          'User-Agent': getRandomUserAgent(),
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
          'Accept-Language': 'vi-VN,vi;q=0.9,en;q=0.8',
          'Accept-Encoding': 'gzip, deflate, br',
          'Connection': 'keep-alive',
          'Upgrade-Insecure-Requests': '1',
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        },
        timeout: 20000,
        maxRedirects: 5,
        validateStatus: (status) => status < 400
      });
      
      if (response.data && typeof response.data === 'string' && response.data.length > 0) {
        const textContent = extractTextFromHTML(response.data);
        const title = extractTitleFromHTML(response.data);
        
        if (textContent && textContent.length > 50) {
          console.log(`‚úÖ Fetch th√†nh c√¥ng: ${textContent.length} k√Ω t·ª± t·ª´ ${url}`);
          return {
            url: url,
            content: textContent,
            title: title || 'Kh√¥ng c√≥ ti√™u ƒë·ªÅ',
            success: true,
            length: textContent.length
          };
        } else {
          console.log(`‚ö†Ô∏è N·ªôi dung qu√° ng·∫Øn: ${textContent?.length || 0} k√Ω t·ª± t·ª´ ${url}`);
          
          // Fallback: th·ª≠ l·∫•y meta description v√† c√°c th√¥ng tin kh√°c
          const $ = cheerio.load(response.data);
          const metaDescription = $('meta[name="description"]').attr('content') || '';
          const metaKeywords = $('meta[name="keywords"]').attr('content') || '';
          const ogDescription = $('meta[property="og:description"]').attr('content') || '';
          const h1Text = $('h1').text().trim();
          const h2Text = $('h2').first().text().trim();
          
          const fallbackContent = [title, h1Text, h2Text, metaDescription, ogDescription, metaKeywords]
            .filter((text): text is string => text !== null && text !== undefined && text.length > 0)
            .join('\n\n');
          
          if (fallbackContent.length > 30) {
            console.log(`‚úÖ S·ª≠ d·ª•ng fallback content: ${fallbackContent.length} k√Ω t·ª± t·ª´ ${url}`);
            return {
              url: url,
              content: fallbackContent,
              title: title || h1Text || 'Kh√¥ng c√≥ ti√™u ƒë·ªÅ',
              success: true,
              length: fallbackContent.length,
              note: 'S·ª≠ d·ª•ng meta data do kh√¥ng tr√≠ch xu·∫•t ƒë∆∞·ª£c n·ªôi dung ch√≠nh'
            };
          }
        }
      }
      
      throw new Error(`Kh√¥ng th·ªÉ tr√≠ch xu·∫•t n·ªôi dung h·ªØu √≠ch t·ª´ ${url}`);
      
    } catch (error) {
      console.log(`‚ùå L·∫ßn th·ª≠ ${attempt} th·∫•t b·∫°i cho ${url}: ${(error as Error).message}`);
      
      if (attempt === maxRetries) {
        return {
          url: url,
          content: '',
          title: '',
          success: false,
          length: 0,
          error: (error as Error).message
        };
      }
      
      // ƒê·ª£i tr∆∞·ªõc khi th·ª≠ l·∫°i
      await new Promise(resolve => setTimeout(resolve, 2000 * attempt));
    }
  }

  // TypeScript requires a return statement here
  return {
    url: url,
    content: '',
    title: '',
    success: false,
    length: 0,
    error: 'Max retries exceeded'
  };
}


// H√†m search Google Custom Search API
async function searchGoogleAPI(query: string, maxResults: number = 10): Promise<SearchResult[]> {
  try {
    const searchUrl = 'https://www.googleapis.com/customsearch/v1';
    
    const params = {
      key: process.env.GOOGLE_SEARCH_API_KEY,
      cx: process.env.GOOGLE_SEARCH_ENGINE_ID,
      q: query,
      num: Math.min(maxResults, 10),
      safe: 'medium',
      lr: 'lang_vi|lang_en'
    };

    const response = await axios.get(searchUrl, { params });
    
    if (response.data.items) {
      return response.data.items.map((item: any) => ({
        title: item.title,
        snippet: item.snippet,
        link: item.link,
        displayLink: item.displayLink,
        formattedUrl: item.formattedUrl
      }));
    }
    
    return [];
  } catch (error) {
    console.error('L·ªói khi g·ªçi Google Search API:', (error as any).response?.data || (error as Error).message);
    return [];
  }
}

// H√†m l·ªçc c√°c URL ƒë√°ng tin c·∫≠y
function filterTrustedUrls(searchResults: SearchResult[]): SearchResult[] {
  const trustedDomains: string[] = [
    'wikipedia.org',
    'gov.vn',
    'edu.vn',
    'bbc.com',
    'cnn.com',
    'reuters.com',
    'ap.org',
    'vnexpress.net',
    'tuoitre.vn',
    'thanhnien.vn',
    'vietnamnet.vn',
    'dantri.com.vn',
    'vietNamNews.vn',
    'bloomberg.com',
    'wsj.com',
    'nytimes.com',
    'theguardian.com',
    'factcheck.org',
    'snopes.com',
    'politifact.com'
  ];
  
  const lowQualityDomains: string[] = [
    'facebook.com',
    'twitter.com',
    'instagram.com',
    'tiktok.com',
    'youtube.com',
    'reddit.com'
  ];
  
  return searchResults.filter(result => {
    const domain = result.displayLink.toLowerCase();
    
    // Lo·∫°i b·ªè domain ch·∫•t l∆∞·ª£ng th·∫•p
    if (lowQualityDomains.some(bad => domain.includes(bad))) {
      return false;
    }
    
    // ∆Øu ti√™n domain ƒë√°ng tin c·∫≠y
    return true;
  }).sort((a, b) => {
    const aTrusted = trustedDomains.some(trusted => a.displayLink.toLowerCase().includes(trusted));
    const bTrusted = trustedDomains.some(trusted => b.displayLink.toLowerCase().includes(trusted));
    
    if (aTrusted && !bTrusted) return -1;
    if (!aTrusted && bTrusted) return 1;
    return 0;
  });
}

// H√†m ki·ªÉm tra xem input c√≥ ph·∫£i l√† URL kh√¥ng
function isValidURL(string: string): boolean {
  try {
    const url = new URL(string.trim());
    return url.protocol === "http:" || url.protocol === "https:";
  } catch (_) {
    return false;
  }
}


// H√†m tr√≠ch xu·∫•t keywords t·ª´ URL path (c·∫£i ti·∫øn cho URL MSN v√† c√°c URL ti·∫øng Vi·ªát)
function extractKeywordsFromURL(urlPath: string): string {
  try {
    console.log("üîç ƒêang ph√¢n t√≠ch URL:", urlPath);
    
    // Decode URL tr∆∞·ªõc
    const decodedPath = decodeURIComponent(urlPath);
    console.log("üîç URL ƒë√£ decode:", decodedPath);
    
    // T√°ch th√†nh c√°c ph·∫ßn
    const pathParts = decodedPath.split('/');
    
    // T√¨m ph·∫ßn ch·ª©a content ti·∫øng Vi·ªát (th∆∞·ªùng c√≥ d·∫•u ho·∫∑c k√Ω t·ª± ƒë·∫∑c bi·ªát)
    let bestKeywords = '';
    let maxScore = 0;
    
    for (const part of pathParts) {
      if (part.length < 5) continue; // B·ªè qua ph·∫ßn qu√° ng·∫Øn
      
      // T√≠nh ƒëi·ªÉm cho m·ªói ph·∫ßn d·ª±a tr√™n:
      let score = 0;
      
      // 1. C√≥ k√Ω t·ª± ti·∫øng Vi·ªát
      if (/[√°√†·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠√©√®·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã√≥√≤·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£√∫√π·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±√Ω·ª≥·ª∑·ªπ·ªµƒë]/i.test(part)) {
        score += 10;
      }
      
      // 2. C√≥ nhi·ªÅu t·ª´ (d·∫•u g·∫°ch ngang)
      const wordCount = part.split(/[-_]/).length;
      score += wordCount;
      
      // 3. ƒê·ªô d√†i h·ª£p l√Ω
      if (part.length > 20 && part.length < 200) {
        score += 5;
      }
      
      // 4. Kh√¥ng ph·∫£i tham s·ªë query
      if (!part.includes('=') && !part.includes('?') && !part.includes('&')) {
        score += 3;
      }
      
      // 5. Kh√¥ng ph·∫£i ID ng·∫´u nhi√™n
      if (!/^[a-zA-Z0-9]{10,}$/.test(part)) {
        score += 2;
      }
      
      console.log(`üîç Ph·∫ßn "${part.substring(0, 50)}..." c√≥ ƒëi·ªÉm: ${score}`);
      
      if (score > maxScore) {
        maxScore = score;
        bestKeywords = part;
      }
    }
    
    if (bestKeywords) {
      // L√†m s·∫°ch keywords t·ªët nh·∫•t
      let cleanKeywords = bestKeywords
        .replace(/[-_]/g, ' ') // Thay g·∫°ch ngang b·∫±ng kho·∫£ng tr·∫Øng
        .replace(/%[0-9A-F]{2}/gi, ' ') // Lo·∫°i b·ªè URL encoding c√≤n s√≥t
        .replace(/[^a-zA-Z0-9\s√°√†·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠√©√®·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã√≥√≤·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£√∫√π·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±√Ω·ª≥·ª∑·ªπ·ªµƒë]/gi, ' ')
        .replace(/\s+/g, ' ')
        .trim();
      
      console.log(`‚úÖ Keywords t·ªët nh·∫•t: "${cleanKeywords}"`);
      return cleanKeywords;
    }
    
    // Fallback: n·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c, th·ª≠ l·∫•y t·ª´ domain v√† path
    const domain = urlPath.split('/')[2] || '';
    const lastPath = pathParts[pathParts.length - 1] || '';
    
    let fallbackKeywords = '';
    
    // N·∫øu l√† MSN, th·ª≠ extract t·ª´ category
    if (domain.includes('msn.com')) {
      // T√¨m category nh∆∞ "lifestyle/living" ho·∫∑c "sports/other"
      const categoryIndex = pathParts.findIndex(part => 
        ['lifestyle', 'sports', 'news', 'entertainment', 'health', 'technology'].includes(part)
      );
      
      if (categoryIndex >= 0 && pathParts[categoryIndex + 1]) {
        fallbackKeywords = `${pathParts[categoryIndex]} ${pathParts[categoryIndex + 1]}`;
      }
    }
    
    if (!fallbackKeywords) {
      // Th·ª≠ l·∫•y t·ª´ path cu·ªëi v√† l√†m s·∫°ch
      fallbackKeywords = lastPath
        .replace(/[^a-zA-Z0-9\s√°√†·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠√©√®·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã√≥√≤·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£√∫√π·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±√Ω·ª≥·ª∑·ªπ·ªµƒë-]/gi, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }
    
    console.log(`üîÑ Fallback keywords: "${fallbackKeywords}"`);
    return fallbackKeywords || 'tin t·ª©c m·ªõi';
    
  } catch (error) {
    console.error("L·ªói extract keywords t·ª´ URL:", error);
    return 'tin t·ª©c';
  }
}


// H√†m ph√¢n t√≠ch n·ªôi dung b∆∞·ªõc 1 ƒë·ªÉ l·∫•y ti√™u ƒë·ªÅ v√† keywords ch√≠nh
async function analyzeFirstStepContent(originalUrl: string, urlKeywords: string, contents: WebContent[]): Promise<FirstStepAnalysisResult | null> {
  if (!contents || contents.length === 0) {
    return null;
  }
  
  const contentSummary = contents.map((content, index) => 
    `--- NGU·ªíN ${index + 1}: ${content.url} ---
TI√äU ƒê·ªÄ: ${content.title}
N·ªòI DUNG: ${content.content.substring(0, 1000)}...`
  ).join('\n\n');

  const prompt = `
B·∫°n l√† chuy√™n gia ph√¢n t√≠ch n·ªôi dung, hi·ªán t·∫°i l√† th√°ng ${thang} nƒÉm ${nam}. Ph√¢n t√≠ch c√°c ngu·ªìn tin sau ƒë·ªÉ x√°c ƒë·ªãnh:

URL G·ªêC: ${originalUrl}
KEYWORDS T·ª™ URL: ${urlKeywords}

C√ÅC NGU·ªíN TIN ƒê√É T√åM ƒê∆Ø·ª¢C (${contents.length} ngu·ªìn):
${contentSummary}

NHI·ªÜM V·ª§:
1. X√°c ƒë·ªãnh TI√äU ƒê·ªÄ CH√çNH c·ªßa s·ª± ki·ªán/tin t·ª©c
2. Tr√≠ch xu·∫•t C√ÅC CH·ª¶ ƒê·ªÄ CH√çNH v√† t·ª´ kh√≥a quan tr·ªçng
3. T√≥m t·∫Øt n·ªôi dung c·ªët l√µi
4. X√°c ƒë·ªãnh c√°c nh√¢n v·∫≠t, ƒë·ªãa ƒëi·ªÉm, s·ª± ki·ªán ch√≠nh

Tr·∫£ l·ªùi theo JSON:
{
  "mainTitle": "ti√™u ƒë·ªÅ ch√≠nh c·ªßa s·ª± ki·ªán",
  "keyTopics": ["ch·ªß ƒë·ªÅ 1", "ch·ªß ƒë·ªÅ 2", "ch·ªß ƒë·ªÅ 3"],
  "coreContent": "t√≥m t·∫Øt n·ªôi dung c·ªët l√µi",
  "mainEntities": ["nh√¢n v·∫≠t/t·ªï ch·ª©c ch√≠nh"],
  "eventLocation": "ƒë·ªãa ƒëi·ªÉm x·∫£y ra s·ª± ki·ªán",
  "eventType": "lo·∫°i s·ª± ki·ªán (ch√≠nh tr·ªã/kinh t·∫ø/x√£ h·ªôi/etc)",
  "urgencyLevel": "m·ª©c ƒë·ªô kh·∫©n c·∫•p (high/medium/low)"
}
`;

  try {
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();
    
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    return jsonMatch ? JSON.parse(jsonMatch[0]) : null;
  } catch (error) {
    console.error("L·ªói ph√¢n t√≠ch b∆∞·ªõc 1:", error);
    return null;
  }
}

// H√†m ph√¢n t√≠ch cu·ªëi c√πng v·ªõi quy tr√¨nh 2 b∆∞·ªõc
async function finalTwoStepAnalysis(
  originalUrl: string, 
  urlKeywords: string, 
  analysisResult: FirstStepAnalysisResult, 
  firstContents: WebContent[], 
  secondContents: WebContent[], 
  allQueries: string[]
): Promise<AnalysisResult | null> {
  const totalSources = firstContents.length + secondContents.length;
  
  const firstContentSummary = firstContents.map((content, index) => 
    `--- NGU·ªíN B∆Ø·ªöC 1.${index + 1}: ${content.url} ---
TI√äU ƒê·ªÄ: ${content.title}
N·ªòI DUNG: ${content.content.substring(0, 800)}...`
  ).join('\n\n');
  
  const secondContentSummary = secondContents.map((content, index) => 
    `--- NGU·ªíN B∆Ø·ªöC 2.${index + 1}: ${content.url} ---
TI√äU ƒê·ªÄ: ${content.title}
N·ªòI DUNG: ${content.content.substring(0, 800)}...`
  ).join('\n\n');

  const prompt = `
B·∫°n l√† chuy√™n gia fact-checking h√†ng ƒë·∫ßu, hi·ªán t·∫°i l√† th√°ng ${thang} nƒÉm ${nam}. Ph√¢n t√≠ch URL b·∫±ng quy tr√¨nh 2 b∆∞·ªõc ƒë√£ ho√†n th√†nh:

URL NGU·ªíN G·ªêC: ${originalUrl}

QUY TR√åNH ƒê√É TH·ª∞C HI·ªÜN:
1. Search d·ª±a tr√™n URL keywords: "${urlKeywords}"
2. Fetch v√† ph√¢n t√≠ch ${firstContents.length} ngu·ªìn ƒë·∫ßu ti√™n
3. X√°c ƒë·ªãnh ti√™u ƒë·ªÅ ch√≠nh: "${analysisResult.mainTitle}"
4. Search l·∫°i d·ª±a tr√™n ti√™u ƒë·ªÅ v√† keywords: ${analysisResult.keyTopics.join(', ')}
5. Fetch th√™m ${secondContents.length} ngu·ªìn b·ªï sung
6. Ph√¢n t√≠ch t·ªïng h·ª£p

PH√ÇN T√çCH B∆Ø·ªöC 1:
Ti√™u ƒë·ªÅ ch√≠nh: ${analysisResult.mainTitle}
Ch·ªß ƒë·ªÅ ch√≠nh: ${analysisResult.keyTopics.join(', ')}
Lo·∫°i s·ª± ki·ªán: ${analysisResult.eventType}
N·ªôi dung c·ªët l√µi: ${analysisResult.coreContent}

NGU·ªíN TIN B∆Ø·ªöC 1 (${firstContents.length} ngu·ªìn):
${firstContentSummary}

NGU·ªíN TIN B∆Ø·ªöC 2 (${secondContents.length} ngu·ªìn):
${secondContentSummary}

NHI·ªÜM V·ª§ PH√ÇN T√çCH CU·ªêI C√ôNG:
1. So s√°nh th√¥ng tin t·ª´ ${totalSources} ngu·ªìn kh√°c nhau
2. ƒê√°nh gi√° ƒë·ªô tin c·∫≠y c·ªßa th√¥ng tin li√™n quan ƒë·∫øn URL g·ªëc
3. X√°c ƒë·ªãnh t√≠nh nh·∫•t qu√°n c·ªßa th√¥ng tin
4. Ph√°t hi·ªán m√¢u thu·∫´n ho·∫∑c x√°c nh·∫≠n
5. ƒê∆∞a ra k·∫øt lu·∫≠n v·ªÅ URL g·ªëc

Tr·∫£ l·ªùi theo JSON:
{
  "isFakeNews": true/false,
  "confidence": s·ªë t·ª´ 0-100,
  "reason": "ph√¢n t√≠ch chi ti·∫øt d·ª±a tr√™n quy tr√¨nh 2 b∆∞·ªõc v·ªõi ${totalSources} ngu·ªìn",
  "indicators": ["d·∫•u hi·ªáu t·ª´ vi·ªác ph√¢n t√≠ch 2 b∆∞·ªõc"],
  "recommendation": "khuy·∫øn ngh·ªã d·ª±a tr√™n cross-reference",
  "twoStepFindings": "k·∫øt qu·∫£ t·ª´ quy tr√¨nh 2 b∆∞·ªõc",
  "firstStepAnalysis": "ph√°t hi·ªán t·ª´ b∆∞·ªõc 1 (${firstContents.length} ngu·ªìn)",
  "secondStepAnalysis": "ph√°t hi·ªán t·ª´ b∆∞·ªõc 2 (${secondContents.length} ngu·ªìn)",
  "consistencyCheck": "m·ª©c ƒë·ªô nh·∫•t qu√°n gi·ªØa ${totalSources} ngu·ªìn",
  "mainTopicVerification": "x√°c minh ch·ªß ƒë·ªÅ ch√≠nh: ${analysisResult.mainTitle}",
  "sourceDistribution": "ph√¢n b·ªë ngu·ªìn tin v√† ƒë·ªô tin c·∫≠y",
  "webEvidenceUsed": true,
  "sourcesAnalyzed": ${totalSources},
  "twoStepProcess": true,
  "originalUrl": "${originalUrl}",
  "searchQueries": ${JSON.stringify(allQueries)},
  "identifiedTitle": "${analysisResult.mainTitle}",
  "keyTopics": ${JSON.stringify(analysisResult.keyTopics)}
}
`;

  try {
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();
    
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    return jsonMatch ? JSON.parse(jsonMatch[0]) : null;
  } catch (error) {
    console.error("L·ªói ph√¢n t√≠ch cu·ªëi c√πng 2 b∆∞·ªõc:", error);
    return {
      isFakeNews: false,
      confidence: 40,
      reason: `Ho√†n th√†nh quy tr√¨nh 2 b∆∞·ªõc v·ªõi ${totalSources} ngu·ªìn nh∆∞ng g·∫∑p l·ªói ph√¢n t√≠ch cu·ªëi: ${(error as Error).message}`,
      indicators: ["L·ªói x·ª≠ l√Ω cu·ªëi c√πng"],
      recommendation: "ƒê√£ thu th·∫≠p ƒë·ªß th√¥ng tin, c·∫ßn xem x√©t th·ªß c√¥ng",
      twoStepProcess: true,
      sourcesAnalyzed: totalSources,
      originalUrl: originalUrl,
      webEvidenceUsed: true
    };
  }
}

// H√†m ph√¢n t√≠ch ƒë∆°n gi·∫£n khi kh√¥ng c√≥ ƒë·ªß d·ªØ li·ªáu
async function simplifiedAnalysis(url: string, urlKeywords: string, contents: WebContent[]): Promise<AnalysisResult> {
  return {
    isFakeNews: false,
    confidence: 50,
    reason: `Ph√¢n t√≠ch ƒë∆°n gi·∫£n cho ${url} v·ªõi ${contents.length} ngu·ªìn`,
    indicators: ["Ph√¢n t√≠ch c∆° b·∫£n"],
    recommendation: "C·∫ßn th√™m th√¥ng tin ƒë·ªÉ ƒë√°nh gi√° ch√≠nh x√°c",
    twoStepProcess: false,
    sourcesAnalyzed: contents.length,
    originalUrl: url,
    webEvidenceUsed: contents.length > 0
  };
}

// H√†m ph√¢n t√≠ch URL theo quy tr√¨nh 2 b∆∞·ªõc v·ªõi fallback khi h·∫øt quota
async function analyzeURL(url: string, originalMessage: string): Promise<AnalysisResult> {
  console.log("üîó B·∫Øt ƒë·∫ßu quy tr√¨nh 2 b∆∞·ªõc cho URL:", url);
  
  // B∆Ø·ªöC 1: T·∫°o keywords t·ª´ URL ƒë·ªÉ search tr∆∞·ªõc
  const urlPath = decodeURIComponent(url);
  const urlKeywords = extractKeywordsFromURL(urlPath);
  console.log("üîç Keywords t·ª´ URL:", urlKeywords);
  
  // B∆Ø·ªöC 2: Search l·∫ßn 1 d·ª±a tr√™n URL keywords
  let firstSearchResults: SearchResult[] = [];
  if (process.env.GOOGLE_SEARCH_API_KEY && process.env.GOOGLE_SEARCH_ENGINE_ID) {
    console.log("üîç B∆Ø·ªöC 1: Search d·ª±a tr√™n URL keywords");
    
    const firstQueries = [
      urlKeywords,
      `"${urlKeywords}"`,
      `${urlKeywords} tin t·ª©c`,
      `${urlKeywords} news`
    ].filter(query => query && query.trim().length > 3);
    
    let hasQuotaError = false;
    
    for (const query of firstQueries.slice(0, 3)) {
      try {
        const searchResults = await searchGoogleAPI(query, 6);
        firstSearchResults = firstSearchResults.concat(searchResults);
        await new Promise(resolve => setTimeout(resolve, 500));
      } catch (error) {
        console.log("L·ªói search l·∫ßn 1:", (error as Error).message);
        
        // Ki·ªÉm tra n·∫øu l√† l·ªói quota
        if ((error as Error).message && (error as Error).message.includes('Quota exceeded')) {
          hasQuotaError = true;
          break;
        }
      }
    }
    
    // N·∫øu h·∫øt quota, chuy·ªÉn sang ph√¢n t√≠ch kh√¥ng c√≥ search
    if (hasQuotaError) {
      console.log("‚ö†Ô∏è Google Search API h·∫øt quota - chuy·ªÉn sang ph√¢n t√≠ch d·ª±a tr√™n AI");
      return await analyzeURLWithoutSearch(url, urlKeywords);
    }
    
    const uniqueFirstResults = firstSearchResults.filter((result, index, self) => 
      index === self.findIndex(r => r.link === result.link)
    );
    const trustedFirstResults = filterTrustedUrls(uniqueFirstResults);
    console.log(`‚úÖ Search l·∫ßn 1: t√¨m th·∫•y ${trustedFirstResults.length} ngu·ªìn`);
    
    // B∆Ø·ªöC 3: Fetch n·ªôi dung t·ª´ search results l·∫ßn 1 (PH·∫¶N B·ªä THI·∫æU TRONG CODE C≈®)
    console.log("üåê B∆Ø·ªöC 2: Fetch n·ªôi dung t·ª´ search l·∫ßn 1");
    const firstFetchPromises = trustedFirstResults.slice(0, 5).map(result => 
      fetchWebContent(result.link)
    );
    
    const firstContents = await Promise.all(firstFetchPromises);
    const successfulFirstContents = firstContents.filter(content => content.success);
    console.log(`‚úÖ Fetch l·∫ßn 1: th√†nh c√¥ng ${successfulFirstContents.length} ngu·ªìn`);
    
    // N·∫øu kh√¥ng c√≥ n·ªôi dung n√†o ƒë∆∞·ª£c fetch th√†nh c√¥ng
    if (successfulFirstContents.length === 0) {
      console.log("‚ö†Ô∏è Kh√¥ng fetch ƒë∆∞·ª£c n·ªôi dung - chuy·ªÉn sang ph√¢n t√≠ch AI");
      return await analyzeURLWithoutSearch(url, urlKeywords);
    }
    
    // B∆Ø·ªöC 4: Ph√¢n t√≠ch n·ªôi dung l·∫ßn 1 ƒë·ªÉ l·∫•y ti√™u ƒë·ªÅ v√† keywords ch√≠nh
    console.log("ü§ñ B∆Ø·ªöC 3: Ph√¢n t√≠ch n·ªôi dung ƒë·ªÉ l·∫•y ti√™u ƒë·ªÅ v√† keywords ch√≠nh");
    const analysisResult = await analyzeFirstStepContent(url, urlKeywords, successfulFirstContents);
    
    if (analysisResult && analysisResult.mainTitle && analysisResult.keyTopics) {
      console.log("üì∞ Ti√™u ƒë·ªÅ ch√≠nh:", analysisResult.mainTitle);
      console.log("üéØ Keywords ch√≠nh:", analysisResult.keyTopics);
      
      // B∆Ø·ªöC 5: Search l·∫ßn 2 d·ª±a tr√™n ti√™u ƒë·ªÅ v√† keywords ƒë√£ ph√¢n t√≠ch
      console.log("üîç B∆Ø·ªöC 4: Search l·∫ßn 2 d·ª±a tr√™n ti√™u ƒë·ªÅ v√† keywords ch√≠nh");
      
      const secondQueries = [
        analysisResult.mainTitle,
        `"${analysisResult.mainTitle}"`,
        analysisResult.keyTopics.join(' '),
        `${analysisResult.mainTitle} fact check`,
        `${analysisResult.keyTopics.join(' ')} x√°c minh`,
        `${analysisResult.mainTitle} tin t·ª©c`
      ].filter(query => query && query.trim().length > 3);
      
      let secondSearchResults: SearchResult[] = [];
      for (const query of secondQueries.slice(0, 5)) {
        try {
          const searchResults = await searchGoogleAPI(query, 6);
          // Lo·∫°i b·ªè nh·ªØng URL ƒë√£ c√≥ t·ª´ l·∫ßn search tr∆∞·ªõc
          const newResults = searchResults.filter(result => 
            !firstSearchResults.some(first => first.link === result.link)
          );
          secondSearchResults = secondSearchResults.concat(newResults);
          await new Promise(resolve => setTimeout(resolve, 500));
        } catch (error) {
          console.log("L·ªói search l·∫ßn 2:", (error as Error).message);
          // N·∫øu h·∫øt quota ·ªü l·∫ßn 2, d·ª´ng search nh∆∞ng v·∫´n ti·∫øp t·ª•c ph√¢n t√≠ch
          if ((error as Error).message && (error as Error).message.includes('Quota exceeded')) {
            console.log("‚ö†Ô∏è H·∫øt quota ·ªü b∆∞·ªõc 2 - s·ª≠ d·ª•ng d·ªØ li·ªáu t·ª´ b∆∞·ªõc 1");
            break;
          }
        }
      }
      
      const uniqueSecondResults = secondSearchResults.filter((result, index, self) => 
        index === self.findIndex(r => r.link === result.link)
      );
      const trustedSecondResults = filterTrustedUrls(uniqueSecondResults);
      console.log(`‚úÖ Search l·∫ßn 2: t√¨m th√™m ${trustedSecondResults.length} ngu·ªìn m·ªõi`);
      
      // B∆Ø·ªöC 6: Fetch n·ªôi dung t·ª´ search results l·∫ßn 2  
      if (trustedSecondResults.length > 0) {
        console.log("üåê B∆Ø·ªöC 5: Fetch n·ªôi dung t·ª´ search l·∫ßn 2");
        const secondFetchPromises = trustedSecondResults.slice(0, 5).map(result => 
          fetchWebContent(result.link)
        );
        
        const secondContents = await Promise.all(secondFetchPromises);
        const successfulSecondContents = secondContents.filter(content => content.success);
        console.log(`‚úÖ Fetch l·∫ßn 2: th√†nh c√¥ng ${successfulSecondContents.length} ngu·ªìn`);
        
        // B∆Ø·ªöC 7: Ph√¢n t√≠ch cu·ªëi c√πng v·ªõi t·∫•t c·∫£ th√¥ng tin
        console.log("üéØ B∆Ø·ªöC 6: Ph√¢n t√≠ch cu·ªëi c√πng v·ªõi to√†n b·ªô th√¥ng tin");
        const finalResult = await finalTwoStepAnalysis(
          url, 
          urlKeywords, 
          analysisResult, 
          successfulFirstContents, 
          successfulSecondContents,
          [...firstQueries, ...secondQueries]
        );
        return finalResult || await simplifiedAnalysis(url, urlKeywords, [...successfulFirstContents, ...successfulSecondContents]);
      } else {
        // Ch·ªâ c√≥ d·ªØ li·ªáu t·ª´ b∆∞·ªõc 1
        console.log("üéØ Ph√¢n t√≠ch v·ªõi d·ªØ li·ªáu t·ª´ b∆∞·ªõc 1");
        const finalResult = await finalTwoStepAnalysis(
          url, 
          urlKeywords, 
          analysisResult, 
          successfulFirstContents, 
          [], // Kh√¥ng c√≥ second contents
          firstQueries
        );
        return finalResult || await simplifiedAnalysis(url, urlKeywords, successfulFirstContents);
      }
    } else {
      // N·∫øu kh√¥ng ph√¢n t√≠ch ƒë∆∞·ª£c n·ªôi dung, ch·ªâ d√πng k·∫øt qu·∫£ l·∫ßn 1
      return await simplifiedAnalysis(url, urlKeywords, successfulFirstContents);
    }
  } else {
    console.log("‚ö†Ô∏è Kh√¥ng c√≥ Google API - kh√¥ng th·ªÉ th·ª±c hi·ªán quy tr√¨nh 2 b∆∞·ªõc");
    return await analyzeURLWithoutSearch(url, urlKeywords);
  }
}


// H√†m ph√¢n t√≠ch URL khi kh√¥ng c√≥ search (fallback)
async function analyzeURLWithoutSearch(url: string, urlKeywords: string): Promise<AnalysisResult> {
  console.log("ü§ñ Ph√¢n t√≠ch URL kh√¥ng c√≥ search - d·ª±a tr√™n AI v√† keywords");
  
  const prompt = `
B·∫°n l√† chuy√™n gia fact-checking, hi·ªán t·∫°i l√† th√°ng ${thang} nƒÉm ${nam}. Ph√¢n t√≠ch URL v√† keywords ƒë∆∞·ª£c tr√≠ch xu·∫•t ƒë·ªÉ ƒë∆∞a ra ƒë√°nh gi√° s∆° b·ªô.

URL G·ªêC: ${url}
KEYWORDS TR√çCH XU·∫§T: ${urlKeywords}

NHI·ªÜM V·ª§ PH√ÇN T√çCH:
1. ƒê√°nh gi√° domain v√† ƒë·ªô tin c·∫≠y c·ªßa ngu·ªìn
2. Ph√¢n t√≠ch keywords ƒë·ªÉ hi·ªÉu ch·ªß ƒë·ªÅ ch√≠nh
3. ƒê∆∞a ra nh·∫≠n ƒë·ªãnh v·ªÅ t√≠nh ch·∫•t c·ªßa th√¥ng tin
4. Khuy·∫øn ngh·ªã c√°ch ki·ªÉm tra th√™m

L∆ØU √ù:
- ƒê√¢y l√† ph√¢n t√≠ch s∆° b·ªô do kh√¥ng c√≥ th√¥ng tin t·ª´ search
- C·∫ßn ki·ªÉm tra cross-reference t·ª´ nhi·ªÅu ngu·ªìn kh√°c
- ƒê√°nh gi√° ch·ªß y·∫øu d·ª±a tr√™n domain v√† keywords

Tr·∫£ l·ªùi theo JSON:
{
  "isFakeNews": true/false,
  "confidence": s·ªë t·ª´ 0-100,
  "reason": "ph√¢n t√≠ch d·ª±a tr√™n domain v√† keywords, kh√¥ng c√≥ cross-reference",
  "indicators": ["d·∫•u hi·ªáu t·ª´ URL v√† keywords"],
  "recommendation": "khuy·∫øn ngh·ªã ki·ªÉm tra th√™m t·ª´ nhi·ªÅu ngu·ªìn",
  "domainAnalysis": "ƒë√°nh gi√° v·ªÅ domain ${url.split('/')[2]}",
  "topicAnalysis": "ph√¢n t√≠ch ch·ªß ƒë·ªÅ t·ª´ keywords: ${urlKeywords}",
  "webEvidenceUsed": false,
  "sourcesAnalyzed": 0,
  "twoStepProcess": false,
  "originalUrl": "${url}",
  "limitedAnalysis": true,
  "reason_limited": "Google Search API h·∫øt quota ho·∫∑c kh√¥ng c√≥"
}
`;

  try {
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();
    
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    return jsonMatch ? JSON.parse(jsonMatch[0]) : {
      isFakeNews: false,
      confidence: 30,
      reason: "Kh√¥ng th·ªÉ ph√¢n t√≠ch do thi·∫øu d·ªØ li·ªáu search",
      indicators: ["C·∫ßn Google Search ƒë·ªÉ ph√¢n t√≠ch ƒë·∫ßy ƒë·ªß"],
      recommendation: "Ki·ªÉm tra th·ªß c√¥ng t·ª´ nhi·ªÅu ngu·ªìn tin ƒë√°ng tin c·∫≠y",
      limitedAnalysis: true,
      originalUrl: url,
      webEvidenceUsed: false,
      sourcesAnalyzed: 0
    };
  } catch (error) {
    console.error("L·ªói ph√¢n t√≠ch kh√¥ng c√≥ search:", error);
    return {
      isFakeNews: false,
      confidence: 20,
      reason: `L·ªói ph√¢n t√≠ch URL ${url}: ${(error as Error).message}`,
      indicators: ["L·ªói h·ªá th·ªëng"],
      recommendation: "C·∫ßn ki·ªÉm tra th·ªß c√¥ng",
      limitedAnalysis: true,
      originalUrl: url,
      error: (error as Error).message,
      webEvidenceUsed: false,
      sourcesAnalyzed: 0
    };
  }
}

// H√†m ph√¢n t√≠ch n·ªôi dung web ƒë√£ fetch
async function analyzeWebContent(originalText: string, webContents: WebContent[]): Promise<WebAnalysisResult | null> {
  if (!webContents || webContents.length === 0) {
    return null;
  }
  
  const validContents = webContents.filter(content => content.success && content.content.length > 200);
  
  if (validContents.length === 0) {
    return null;
  }
  
  const contentSummary = validContents.map((content, index) => 
    `--- NGU·ªíN ${index + 1}: ${content.url} ---
TI√äU ƒê·ªÄ: ${content.title}
N·ªòI DUNG: ${content.content.substring(0, 2000)}...
(T·ªïng c·ªông: ${content.length} k√Ω t·ª±)
`
  ).join('\n\n');

  const prompt = `
B·∫°n l√† chuy√™n gia ph√¢n t√≠ch th√¥ng tin h√†ng ƒë·∫ßu, hi·ªán t·∫°i l√† th√°ng ${thang} nƒÉm ${nam}. Ph√¢n t√≠ch TO√ÄN B·ªò n·ªôi dung t·ª´ c√°c trang web ƒë√£ thu th·∫≠p ƒë·ªÉ ƒë∆∞a ra ƒë√°nh gi√° ch√≠nh x√°c nh·∫•t v·ªÅ tuy√™n b·ªë:

TUY√äN B·ªê C·∫¶N KI·ªÇM TRA: "${originalText}"

N·ªòI DUNG CHI TI·∫æT T·ª™ C√ÅC TRANG WEB:
${contentSummary}

NHI·ªÜM V·ª§ PH√ÇN T√çCH S√ÇU:

1. ƒê·ªåC K·ª∏ TO√ÄN B·ªò n·ªôi dung t·ª´ t·∫•t c·∫£ c√°c ngu·ªìn
2. PH√ÇN T√çCH m·ªëi li√™n h·ªá gi·ªØa tuy√™n b·ªë v√† th√¥ng tin thu th·∫≠p ƒë∆∞·ª£c
3. X√ÅC ƒê·ªäNH c√°c b·∫±ng ch·ª©ng ·ªßng h·ªô v√† ph·∫£n b√°c c·ª• th·ªÉ
4. ƒê√ÅNH GI√Å ƒë·ªô tin c·∫≠y c·ªßa t·ª´ng ngu·ªìn
5. XEM X√âT ng·ªØ c·∫£nh, th·ªùi gian, ƒë·ªãa ƒëi·ªÉm c·ªßa th√¥ng tin
6. PH√ÅT HI·ªÜN c√°c s·∫Øc th√°i, ngo·∫°i l·ªá, ƒëi·ªÅu ki·ªán ƒë·∫∑c bi·ªát
7. SO S√ÅNH th√¥ng tin t·ª´ nhi·ªÅu ngu·ªìn kh√°c nhau

Y√äU C·∫¶U PH√ÇN T√çCH:
- Ph·∫£i d·ª±a tr√™n TO√ÄN B·ªò n·ªôi dung ƒë√£ ƒë·ªçc, kh√¥ng ch·ªâ snippet
- Tr√≠ch d·∫´n C·ª§ TH·ªÇ t·ª´ c√°c ngu·ªìn ƒë·ªÉ minh ch·ª©ng
- Gi·∫£i th√≠ch chi ti·∫øt l√Ω do k·∫øt lu·∫≠n
- Xem x√©t m·ªçi kh√≠a c·∫°nh c√≥ th·ªÉ

Tr·∫£ l·ªùi theo JSON:
{
  "detailedAnalysis": "ph√¢n t√≠ch chi ti·∫øt d·ª±a tr√™n to√†n b·ªô n·ªôi dung ƒë√£ ƒë·ªçc",
  "supportingEvidence": ["b·∫±ng ch·ª©ng ·ªßng h·ªô C·ª§ TH·ªÇ v·ªõi tr√≠ch d·∫´n"],
  "contradictingEvidence": ["b·∫±ng ch·ª©ng ph·∫£n b√°c C·ª§ TH·ªÇ v·ªõi tr√≠ch d·∫´n"],
  "sourceAnalysis": {
    "source1": "ƒë√°nh gi√° chi ti·∫øt ngu·ªìn 1",
    "source2": "ƒë√°nh gi√° chi ti·∫øt ngu·ªìn 2"
  },
  "contextualFactors": ["y·∫øu t·ªë ng·ªØ c·∫£nh quan tr·ªçng"],
  "nuancesFound": ["c√°c s·∫Øc th√°i, ngo·∫°i l·ªá ph√°t hi·ªán ƒë∆∞·ª£c"],
  "crossReferenceFindings": "k·∫øt qu·∫£ so s√°nh th√¥ng tin gi·ªØa c√°c ngu·ªìn",
  "contentBasedConclusion": "k·∫øt lu·∫≠n d·ª±a tr√™n ph√¢n t√≠ch s√¢u n·ªôi dung"
}
`;

  try {
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const responseText = response.text();
    
    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
    return jsonMatch ? JSON.parse(jsonMatch[0]) : null;
  } catch (error) {
    console.error("L·ªói ph√¢n t√≠ch n·ªôi dung web:", error);
    return null;
  }
}


// Route ph√¢n t√≠ch tin t·ª©c v·ªõi Gemini v√† Web Content Analysis
app.post("/api/analyze", async (req: Request, res: Response): Promise<void> => {
  try {
    const { message }: { message: string } = req.body;

    if (!message || message.trim() === "") {
      res.status(400).json({
        error: "Vui l√≤ng nh·∫≠p n·ªôi dung c·∫ßn ph√¢n t√≠ch"
      });
      return;
    }

    console.log("üìù B·∫Øt ƒë·∫ßu ph√¢n t√≠ch:", message.substring(0, 100) + "...");

    // KI·ªÇM TRA XEM INPUT C√ì PH·∫¢I L√Ä URL KH√îNG
    if (isValidURL(message)) {
      console.log("üîó Ph√°t hi·ªán URL - chuy·ªÉn sang quy tr√¨nh 2 b∆∞·ªõc");
      
      try {
        const urlAnalysis = await analyzeURL(message, message);
        
        const responseData: ApiResponse = {
          success: true,
          analysis: urlAnalysis,
          originalText: message,
          twoStepProcess: true,
          originalUrl: message
        };

        // Th√™m th√¥ng tin v·ªÅ quy tr√¨nh 2 b∆∞·ªõc n·∫øu c√≥
        if (urlAnalysis.twoStepProcess) {
          responseData.statistics = {
            analysisMode: "Two-Step URL Analysis",
            originalUrl: message,
            sourcesAnalyzed: urlAnalysis.sourcesAnalyzed || 0,
            identifiedTitle: urlAnalysis.identifiedTitle || "Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c",
            keyTopics: urlAnalysis.keyTopics || [],
            searchQueries: urlAnalysis.searchQueries || [],
            twoStepEnabled: true
          };
        } else {
          responseData.statistics = {
            analysisMode: "Basic URL Analysis",
            originalUrl: message,
            sourcesAnalyzed: urlAnalysis.sourcesAnalyzed || 0,
            twoStepEnabled: false,
            note: "C·∫ßn Google API ƒë·ªÉ b·∫≠t quy tr√¨nh 2 b∆∞·ªõc"
          };
        }

        res.json(responseData);
        return;
        
      } catch (error) {
        console.error("‚ùå L·ªói khi ph√¢n t√≠ch URL:", error);
        res.status(500).json({
          error: "Kh√¥ng th·ªÉ ph√¢n t√≠ch URL ƒë∆∞·ª£c cung c·∫•p",
          details: (error as Error).message,
          url: message
        });
        return;
      }
    }

    // TI·∫æP T·ª§C V·ªöI PH√ÇN T√çCH TH√îNG TH∆Ø·ªúNG
    console.log("üìù Ph√¢n t√≠ch text th√¥ng th∆∞·ªùng");

    // B∆Ø·ªöC 1: T√¨m ki·∫øm Google (n·∫øu c√≥ API key)
    let allSearchResults: SearchResult[] = [];
    let webContents: WebContent[] = [];
    let webAnalysis: WebAnalysisResult | null = null;
    
    if (process.env.GOOGLE_SEARCH_API_KEY && process.env.GOOGLE_SEARCH_ENGINE_ID) {
      console.log("üîç B∆∞·ªõc 1: T√¨m ki·∫øm th√¥ng tin...");
      const searchQueries = [
        message.substring(0, 200),
        `"${message.substring(0, 100)}"`,
        `${message.substring(0, 100)} fact check`,
        `${message.substring(0, 100)} tin t·ª©c`,
        `${message.substring(0, 100)} s·ª± th·∫≠t`
      ];

      for (const query of searchQueries.slice(0, 4)) {
        try {
          const searchResults = await searchGoogleAPI(query, 8);
          allSearchResults = allSearchResults.concat(searchResults);
          await new Promise(resolve => setTimeout(resolve, 500));
        } catch (error) {
          console.log("L·ªói search:", (error as Error).message);
        }
      }

      // Lo·∫°i b·ªè tr√πng l·∫∑p v√† l·ªçc URL ƒë√°ng tin c·∫≠y
      const uniqueResults = allSearchResults.filter((result, index, self) => 
        index === self.findIndex(r => r.link === result.link)
      );
      
      const trustedResults = filterTrustedUrls(uniqueResults);
      console.log(`‚úÖ T√¨m th·∫•y ${trustedResults.length} k·∫øt qu·∫£ ƒë√°ng tin c·∫≠y`);

      // B∆Ø·ªöC 2: Fetch n·ªôi dung t·ª´ c√°c trang web
      if (trustedResults.length > 0) {
        console.log("üåê B∆∞·ªõc 2: ƒêang t·∫£i n·ªôi dung t·ª´ c√°c trang web...");
        const maxSitesToFetch = 8;
        const fetchPromises = trustedResults.slice(0, maxSitesToFetch).map(result => 
          fetchWebContent(result.link)
        );

        webContents = await Promise.all(fetchPromises);
        const successfulFetches = webContents.filter(content => content.success);
        
        console.log(`‚úÖ ƒê√£ t·∫£i th√†nh c√¥ng ${successfulFetches.length}/${maxSitesToFetch} trang web`);

        // B∆Ø·ªöC 3: Ph√¢n t√≠ch n·ªôi dung web n·∫øu c√≥
        if (successfulFetches.length > 0) {
          console.log("üîç B∆∞·ªõc 3: Ph√¢n t√≠ch chi ti·∫øt n·ªôi dung web...");
          webAnalysis = await analyzeWebContent(message, webContents);
        }
      }
    }

    // B∆Ø·ªöC 4: Ph√¢n t√≠ch ch√≠nh v·ªõi Gemini (lu√¥n ch·∫°y)
    console.log("ü§ñ Ph√¢n t√≠ch ch√≠nh v·ªõi Gemini AI...");
    
    let enhancedPrompt: string;
    if (webAnalysis && webContents.filter(c => c.success).length > 0) {
      // Prompt v·ªõi d·ªØ li·ªáu web
      const webContentSummary = webContents
        .filter(c => c.success)
        .map(c => `‚Ä¢ ${c.url}: ${c.content.substring(0, 300)}...`)
        .join('\n');
      
      enhancedPrompt = `
B·∫°n l√† m·ªôt chuy√™n gia ph√¢n t√≠ch tin t·ª©c v·ªõi kh·∫£ nƒÉng t√≠ch h·ª£p th√¥ng tin t·ª´ nhi·ªÅu ngu·ªìn, hi·ªán t·∫°i l√† th√°ng ${thang} nƒÉm ${nam}. 

TUY√äN B·ªê C·∫¶N PH√ÇN T√çCH: "${message}"

TH√îNG TIN B·ªî SUNG T·ª™ WEB (${webContents.filter(c => c.success).length} ngu·ªìn):
${webContentSummary}

K·∫æT QU·∫¢ PH√ÇN T√çCH WEB:
${JSON.stringify(webAnalysis, null, 2)}

H√£y ph√¢n t√≠ch t·ªïng h·ª£p v√† x√°c ƒë·ªãnh:
1. ƒê√¢y c√≥ ph·∫£i l√† tin gi·∫£ (fake news) kh√¥ng?
2. M·ª©c ƒë·ªô tin c·∫≠y (t·ª´ 0-100%)
3. L√Ω do chi ti·∫øt d·ª±a tr√™n c·∫£ AI analysis v√† web evidence
4. C√°c d·∫•u hi·ªáu nh·∫≠n bi·∫øt
5. So s√°nh v·ªõi th√¥ng tin t√¨m ƒë∆∞·ª£c t·ª´ web

Tr·∫£ l·ªùi theo ƒë·ªãnh d·∫°ng JSON:
{
  "isFakeNews": true/false,
  "confidence": s·ªë t·ª´ 0-100,
  "reason": "l√Ω do chi ti·∫øt t√≠ch h·ª£p web evidence",
  "indicators": ["d·∫•u hi·ªáu 1", "d·∫•u hi·ªáu 2"],
  "recommendation": "khuy·∫øn ngh·ªã cho ng∆∞·ªùi ƒë·ªçc",
  "webEvidenceUsed": true/false,
  "sourcesAnalyzed": ${webContents.filter(c => c.success).length}
}
`;
    } else {
      // Prompt c∆° b·∫£n khi kh√¥ng c√≥ web data
      enhancedPrompt = `
B·∫°n l√† m·ªôt chuy√™n gia ph√¢n t√≠ch tin t·ª©c, hi·ªán t·∫°i l√† th√°ng ${thang} nƒÉm ${nam}. H√£y ph√¢n t√≠ch ƒëo·∫°n vƒÉn b·∫£n sau v√† x√°c ƒë·ªãnh:
1. ƒê√¢y c√≥ ph·∫£i l√† tin gi·∫£ (fake news) kh√¥ng?
2. M·ª©c ƒë·ªô tin c·∫≠y (t·ª´ 0-100%)
3. L√Ω do t·∫°i sao b·∫°n ƒë∆∞a ra k·∫øt lu·∫≠n n√†y
4. C√°c d·∫•u hi·ªáu nh·∫≠n bi·∫øt

VƒÉn b·∫£n c·∫ßn ph√¢n t√≠ch: "${message}"

Tr·∫£ l·ªùi theo ƒë·ªãnh d·∫°ng JSON:
{
  "isFakeNews": true/false,
  "confidence": s·ªë t·ª´ 0-100,
  "reason": "l√Ω do chi ti·∫øt",
  "indicators": ["d·∫•u hi·ªáu 1", "d·∫•u hi·ªáu 2"],
  "recommendation": "khuy·∫øn ngh·ªã cho ng∆∞·ªùi ƒë·ªçc",
  "webEvidenceUsed": false,
  "sourcesAnalyzed": 0
}
`;
    }

    // G·ªçi Gemini API
    const result = await model.generateContent(enhancedPrompt);
    const response = await result.response;
    const text = response.text();

    // Parse JSON response t·ª´ Gemini
    let analysisResult: AnalysisResult;
    try {
      const jsonMatch = text.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        analysisResult = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error("Kh√¥ng th·ªÉ parse JSON");
      }
    } catch (parseError) {
      // N·∫øu kh√¥ng parse ƒë∆∞·ª£c JSON, t·∫°o response m·∫∑c ƒë·ªãnh
      analysisResult = {
        isFakeNews: false,
        confidence: 50,
        reason: text.substring(0, 200) + "...",
        indicators: ["C·∫ßn ph√¢n t√≠ch th√™m"],
        recommendation: "H√£y ki·ªÉm tra t·ª´ nhi·ªÅu ngu·ªìn kh√°c nhau",
        webEvidenceUsed: webAnalysis ? true : false,
        sourcesAnalyzed: webContents.filter(c => c.success).length
      };
    }

    console.log("‚úÖ Ho√†n th√†nh ph√¢n t√≠ch");

    // Response v·ªõi d·ªØ li·ªáu ƒë·∫ßy ƒë·ªß
    const responseData: ApiResponse = {
      success: true,
      analysis: analysisResult,
      originalText: message
    };

    // Th√™m th√¥ng tin web n·∫øu c√≥
    if (webContents.length > 0) {
      responseData.webContents = webContents
        .filter(content => content.success)
        .map(content => ({
          url: content.url,
          title: content.title,
          length: content.length,
          preview: content.content.substring(0, 300) + "..."
        }));
      
      responseData.statistics = {
        totalSitesFound: allSearchResults.length,
        sitesAnalyzed: webContents.filter(c => c.success).length,
        totalContentLength: webContents.filter(c => c.success).reduce((sum, content) => sum + content.length, 0),
        sourceDomains: [...new Set(webContents.filter(c => c.success).map(content => content.url.split('/')[2]))]
      };
    }

    res.json(responseData);

  } catch (error) {
    console.error("‚ùå L·ªói khi ph√¢n t√≠ch:", error);
    res.status(500).json({
      error: "C√≥ l·ªói x·∫£y ra khi ph√¢n t√≠ch n·ªôi dung",
      details: (error as Error).message
    });
  }
});


// Export type v√† function declarations
export type { AnalysisResult };

// Route test API
app.get("/api/test", (req: Request, res: Response): void => {
  res.json({
    message: "Backend ƒëang ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng!",
    geminiConfigured: !!process.env.GEMINI_API_KEY,
    googleSearchConfigured: !!(process.env.GOOGLE_SEARCH_API_KEY && process.env.GOOGLE_SEARCH_ENGINE_ID),
    features: [
      "üîó Two-Step URL Analysis Process",
      "üîç Step 1: Search based on URL keywords", 
      "üì∞ Step 2: Extract title & content from sources",
      "üîç Step 3: Search again with extracted content",
      "üìä Step 4: Cross-reference multiple sources", 
      "üìù Text-based fact checking", 
      "üåê Deep web content fetching",
      "üõ°Ô∏è Trusted domain filtering",
      "ü§ñ AI-powered comprehensive analysis"
    ],
    analysisMode: {
      "URL Input": "Quy tr√¨nh 2 b∆∞·ªõc: Search URL keywords ‚Üí Fetch & analyze ‚Üí Search v·ªõi title/content ‚Üí Final analysis",
      "Text Input": "Fact-check vƒÉn b·∫£n + t√¨m ki·∫øm b·ªï sung",
      "Two-Step Process": process.env.GOOGLE_SEARCH_API_KEY ? "Enabled" : "Disabled - c·∫ßn Google API"
    },
    webCrawlingEnabled: !!(process.env.GOOGLE_SEARCH_API_KEY && process.env.GOOGLE_SEARCH_ENGINE_ID),
    timestamp: new Date().toISOString()
  });
});

// Routes qu·∫£n l√Ω l·ªãch s·ª≠
app.get("/api/history", (req: Request, res: Response): void => {
  res.json({
    success: true,
    history: analysisHistory
  });
});

app.delete("/api/history", (req: Request, res: Response): void => {
  try {
    analysisHistory = [];
    res.json({
      success: true,
      message: "ƒê√£ x√≥a to√†n b·ªô l·ªãch s·ª≠ th√†nh c√¥ng",
      historyCount: 0
    });
  } catch (error) {
    console.error("‚ùå L·ªói khi x√≥a l·ªãch s·ª≠:", error);
    res.status(500).json({
      success: false,
      error: "Kh√¥ng th·ªÉ x√≥a l·ªãch s·ª≠"
    });
  }
});

app.delete("/api/history/:id", (req: Request, res: Response): void => {
  try {
    const itemId = parseInt(req.params.id);
    
    if (!itemId) {
      res.status(400).json({
        success: false,
        error: "ID kh√¥ng h·ª£p l·ªá"
      });
      return;
    }
    
    const initialLength = analysisHistory.length;
    analysisHistory = analysisHistory.filter(item => item.id !== itemId);
    
    if (analysisHistory.length === initialLength) {
      res.status(404).json({
        success: false,
        error: "Kh√¥ng t√¨m th·∫•y item v·ªõi ID n√†y"
      });
      return;
    }
    
    res.json({
      success: true,
      message: "ƒê√£ x√≥a item th√†nh c√¥ng",
      deletedId: itemId,
      remainingCount: analysisHistory.length
    });
  } catch (error) {
    console.error("‚ùå L·ªói khi x√≥a item:", error);
    res.status(500).json({
      success: false,
      error: "Kh√¥ng th·ªÉ x√≥a item"
    });
  }
});

app.get("/api/history/stats", (req: Request, res: Response): void => {
  try {
    const total = analysisHistory.length;
    const fakeCount = analysisHistory.filter(item => item.result.isFakeNews).length;
    const realCount = total - fakeCount;
    const urlAnalyses = analysisHistory.filter(item => item.analysisType.includes('URL')).length;
    const textAnalyses = total - urlAnalyses;
    const twoStepAnalyses = analysisHistory.filter(item => item.twoStepProcess).length;
    
    const avgConfidence = total > 0 
      ? Math.round(analysisHistory.reduce((sum, item) => sum + item.result.confidence, 0) / total)
      : 0;
    
    // Th·ªëng k√™ theo th·ªùi gian
    const today = new Date().toDateString();
    const todayCount = analysisHistory.filter(item => 
      new Date(item.timestamp).toDateString() === today
    ).length;
    
    const thisWeek = new Date();
    thisWeek.setDate(thisWeek.getDate() - 7);
    const weekCount = analysisHistory.filter(item => 
      new Date(item.timestamp) >= thisWeek
    ).length;
    
    const thisMonth = new Date();
    thisMonth.setMonth(thisMonth.getMonth() - 1);
    const monthCount = analysisHistory.filter(item => 
      new Date(item.timestamp) >= thisMonth
    ).length;
    
    res.json({
      success: true,
      stats: {
        total,
        fakeCount,
        realCount,
        urlAnalyses,
        textAnalyses,
        twoStepAnalyses,
        avgConfidence,
        timeStats: {
          today: todayCount,
          thisWeek: weekCount,
          thisMonth: monthCount
        }
      }
    });
  } catch (error) {
    console.error("‚ùå L·ªói khi l·∫•y th·ªëng k√™:", error);
    res.status(500).json({
      success: false,
      error: "Kh√¥ng th·ªÉ l·∫•y th·ªëng k√™"
    });
  }
});

// Middleware l∆∞u l·ªãch s·ª≠
app.use((req: Request, res: Response, next: NextFunction) => {
  if (req.method === 'POST' && (req.path === '/api/analyze' || req.path === '/api/analyze-url')) {
    const originalJson = res.json;
    res.json = function (data: any) {
      if (data.success && data.analysis) {
        const historyEntry: HistoryEntry = {
          id: Date.now(),
          text: data.originalText,
          result: data.analysis,
          sourcesAnalyzed: data.statistics ? data.statistics.sourcesAnalyzed : 0,
          analysisType: data.twoStepProcess ? 'Two-Step URL Analysis' : 'Text Analysis',
          timestamp: new Date().toISOString()
        };

// Export type ƒë·ªÉ c√≥ th·ªÉ s·ª≠ d·ª•ng ·ªü n∆°i kh√°c
        // Th√™m th√¥ng tin URL analysis n·∫øu c√≥
        if (data.twoStepProcess) {
          historyEntry.originalUrl = data.originalUrl;
          historyEntry.identifiedTitle = data.analysis.identifiedTitle;
          historyEntry.keyTopics = data.analysis.keyTopics;
          historyEntry.twoStepProcess = true;
        }

        analysisHistory.unshift(historyEntry);

        // Gi·ªØ t·ªëi ƒëa 50 records
        if (analysisHistory.length > 50) {
          analysisHistory = analysisHistory.slice(0, 50);
        }
      }
      originalJson.call(this, data);
    };
  }
  next();
});

app.listen(port, () => {
  console.log(`‚úÖ Backend ƒëang ch·∫°y t·∫°i http://localhost:${port}`);
  console.log(`ü§ñ Gemini API: ${process.env.GEMINI_API_KEY ? 'ƒê√£ c·∫•u h√¨nh' : 'Ch∆∞a c·∫•u h√¨nh'}`);
  console.log(`üîç Google Search API: ${process.env.GOOGLE_SEARCH_API_KEY ? 'ƒê√£ c·∫•u h√¨nh' : 'Ch∆∞a c·∫•u h√¨nh'}`);
  console.log(`üåê Web Content Analysis: ${process.env.GOOGLE_SEARCH_API_KEY ? 'Enabled' : 'Disabled - ch·ªâ d√πng Gemini AI'}`);
});

/**
 * G·ªçi Gemini API ƒë·ªÉ ph√¢n t√≠ch n·ªôi dung tin t·ª©c (compatibility function)
 * @param message N·ªôi dung c·∫ßn ph√¢n t√≠ch
 * @returns K·∫øt qu·∫£ ph√¢n t√≠ch d∆∞·ªõi d·∫°ng JSON
 */
export const callGeminiAPI = async (message: string): Promise<AnalysisResult> => {
  const prompt = `B·∫°n l√† m·ªôt chuy√™n gia ph√¢n t√≠ch tin t·ª©c, hi·ªán t·∫°i l√† th√°ng ${thang} nƒÉm ${nam}. H√£y ph√¢n t√≠ch ƒëo·∫°n vƒÉn b·∫£n sau v√† x√°c ƒë·ªãnh:
1. ƒê√¢y c√≥ ph·∫£i l√† tin gi·∫£ (fake news) kh√¥ng?
2. M·ª©c ƒë·ªô tin c·∫≠y (t·ª´ 0-100%)
3. L√Ω do t·∫°i sao b·∫°n ƒë∆∞a ra k·∫øt lu·∫≠n n√†y
4. C√°c d·∫•u hi·ªáu nh·∫≠n bi·∫øt

VƒÉn b·∫£n c·∫ßn ph√¢n t√≠ch: "${message}"

Tr·∫£ l·ªùi theo ƒë·ªãnh d·∫°ng JSON:
{
  "isFakeNews": true/false,
  "confidence": s·ªë t·ª´ 0-100,
  "reason": "l√Ω do chi ti·∫øt",
  "indicators": ["d·∫•u hi·ªáu 1", "d·∫•u hi·ªáu 2"],
  "recommendation": "khuy·∫øn ngh·ªã cho ng∆∞·ªùi ƒë·ªçc"
}
`;

  console.log("G·ªçi ƒë·∫øn Gemini...");
  const result = await model.generateContent(prompt);
  console.log("ƒê√£ c√≥ result.");
  const response = result.response;
  const text = response.text();

  try {
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const parsedResult = JSON.parse(jsonMatch[0]);
      return {
        ...parsedResult,
        webEvidenceUsed: false,
        sourcesAnalyzed: 0
      };
    } else {
      throw new Error("Kh√¥ng th·ªÉ parse JSON t·ª´ Gemini");
    }
  } catch (error) {
    // N·∫øu kh√¥ng parse ƒë∆∞·ª£c, tr·∫£ v·ªÅ k·∫øt qu·∫£ m·∫∑c ƒë·ªãnh
    return {
      isFakeNews: false,
      confidence: 50,
      reason: text.substring(0, 200) + "...",
      indicators: ["C·∫ßn ph√¢n t√≠ch th√™m"],
      recommendation: "H√£y ki·ªÉm tra t·ª´ nhi·ªÅu ngu·ªìn kh√°c nhau",
      webEvidenceUsed: false,
      sourcesAnalyzed: 0
    };
  }
};